/**
*
* DO NOT EDIT THIS FILE. EDIT .js6 INSTEAD
*
*/

// Copyright 2017 Telefónica Digital España S.L.
//
// This file is part of UrboCore Processing.
//
// UrboCore Processing is free software: you can redistribute it and/or
// modify it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// UrboCore Processing is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero
// General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with UrboCore Processing. If not, see http://www.gnu.org/licenses/.
//
// For those usages not covered by this license please contact with
// iot_support at tid dot es

'use strict';

var addJob = require('./common').addJob;
var translatedToTimezone = require('./common').translatedToTimezone;
var CartoDBModel = require('../models/cartodbmodel.js');
var config = require('../config');
var moment = require('moment-timezone');
var PGSQLModel = require('../models/pgsqlmodel');
var schedule = require('node-schedule');
var util = require('util');
var utils = require('../utils');
var log = utils.log();

var pgsqlConfig = config.getData().pgsql;
var cartoConfig = config.getData().cartodb;

var process = require('process');
// Singleton queue object
var queue = require('kue').createQueue();
var cluster = require('cluster');

class BaseJob {
  constructor(cfg) {
    this.cfg = cfg;
    this.name = cfg.name || cfg.type;
    this.tableName = cfg.tableName;
    this.pgModel = new PGSQLModel(pgsqlConfig);

    this.scopes = this.getScopes(cfg.scopes || null, cfg.category).then(function (scopes) {
      this.scopes = scopes;
      this.cartoModels = {};
      this.cartoConfigs = {};
      this.schemaToScope = {}; // Niapa, but necesary

      scopes.forEach(function (scope) {
        var currentCartoConfig = cartoConfig.accounts[scope.carto_user];
        currentCartoConfig.user = scope.carto_user;

        this.cartoConfigs[scope.id_scope] = currentCartoConfig;
        this.cartoModels[scope.id_scope] = cartoConfig.active && cfg.carto ? new CartoDBModel(currentCartoConfig) : null;
        this.schemaToScope[scope.dbschema] = scope.id_scope;
      }.bind(this));

      // Controls whether aggregation can be enqueued or not
      this.populate = false;

      // Tables check and initialization
      this.init();
    }.bind(this)).catch(function (err) {
      log.error('Cosntructor error: ', err);
    });
  }

  getFullCartoTableName(dbschema) {
    var checkTableName = `${dbschema}_${this.tableName}`;
    return checkTableName;
  }

  getCartoIndexName(dbschema) {
    var scope = this.schemaToScope[dbschema];
    var currentCartoConfig = this.cartoConfigs[scope];

    var checkTableName = `${dbschema}_${this.tableName}`;
    var enterpriseIndex = currentCartoConfig.enterprise ? `${currentCartoConfig.user.toLowerCase().replace(new RegExp('-', 'g'), '_')}_` : '';
    var cartoIndexName = `${enterpriseIndex}${checkTableName}_idx`;

    if (cartoIndexName.length > 63) {
      // 63 is the max. lenght for names in PSQL
      var cartoIndexName = cartoIndexName.substr(cartoIndexName.length - 63);
    }
    return cartoIndexName;
  }

  init() {
    // Parallel processing for PGSQL and CARTO, if carto
    var promises = [];
    this.scopes.forEach(function (scope) {
      promises.push(function () {
        return this.checkTable(scope.dbschema, scope.id_scope).then(function (data) {
          return this.createTable(data);
        }.bind(this)).then(function (data) {
          return Promise.resolve(data);
        }).catch(function (err) {
          log.error(err);
          return Promise.reject(err);
        });
      }.bind(this)());

      if (this.cartoModels[scope.id_scope]) {
        promises.push(function () {

          return this.checkCartoTable(scope.dbschema, scope.id_scope).done(function (data) {

            if (data.rows[0].n === 0) {
              return this.createCartoTable({ count: data.rows[0].n, dbschema: scope.dbschema }, scope.id_scope).done(function (data) {
                return Promise.resolve(data);
              }).error(function (err) {
                log.error(err);
                return Promise.reject(err);
              });
            } else {
              return Promise.resolve([true]);
            }
          }.bind(this)).error(function (err) {
            log.error(err);
            return Promise.reject(err);
          });
        }.bind(this)());
      }
    }.bind(this));

    Promise.all(promises).then(function (results) {
      log.info('Initialization completed for', this.name);
      this.populate = true;

      if (cluster.isWorker && !process.env.APIONLY) {
        // The workers will process the queue
        log.info('Starting out', this.name, 'queue for worker', cluster.worker.id);
        queue.process(this.name, function (job, done) {
          this.aggregate(job, done);
        }.bind(this));
      } else if (cluster.isMaster) {
        // And the master will schedule the jobs
        log.info('Scheduling task: ' + JSON.stringify(this.cfg));
        this.schedule();
      }
    }.bind(this)).catch(function (err) {
      return Promise.reject(err);
    });
  }

  checkTable(dbschema, idScope) {
    log.info('Running checkTable for', idScope, this.name);
    var tableName = `${dbschema}.${this.tableName}`;
    var sqlTableExists = `SELECT to_regclass('${tableName}') as n`;

    return this.pgModel.promise_query(sqlTableExists).then(function (data) {
      return Promise.resolve({ count: data.rows[0].n || 0, dbschema: dbschema });
    }).catch(function (err) {
      log.error(err);
      return Promise.reject(err);
    });
  }

  checkCartoTable(dbschema, idScope) {
    log.info('Running checkCartoTable for', idScope, this.name);
    var currentCartoConfig = this.cartoConfigs[idScope];

    var checkTableName = `${dbschema}_${this.tableName}`;
    var enterpriseTable = currentCartoConfig.enterprise ? `"${currentCartoConfig.user}".` : '';
    var tableName = enterpriseTable + checkTableName;

    if (currentCartoConfig.enterprise) {
      var sqlTableExists = `SELECT count(*) as n FROM urbo_get_user_tables('${currentCartoConfig.user}') WHERE urbo_get_user_tables = '${checkTableName}'`;
    } else {
      var sqlTableExists = `SELECT COUNT(cdb_usertables) as n FROM cdb_usertables() WHERE cdb_usertables = '${tableName}'`;
    }

    // `this.cartoModels[idScope]` don't need to be checked, the function that calls `checkCartoTable` checks it
    return this.cartoModels[idScope].promise_query({ query: sqlTableExists }).done(function (data) {
      return Promise.resolve({ count: data.rows[0].n, dbschema: dbschema });
    }).error(function (err) {
      log.error(err);
      return Promise.reject(err);
    });
  }

  getScopes(scopes, category) {
    // Getting scopes, schemas, timezone and carto account
    var sql = `SELECT scopes.id_scope, scopes.dbschema, scopes.timezone,
          categories.config->'carto'->'account' AS carto_user
        FROM (SELECT id_scope, config FROM metadata.categories_scopes
              WHERE id_category = '${category}') categories
          INNER JOIN metadata.scopes scopes ON categories.id_scope = scopes.id_scope`;

    if (scopes) {
      sql += ` WHERE scopes.id_scope IN ('${scopes.join("', '")}')`;
    }

    return this.pgModel.promise_query(sql).then(function (data) {
      return Promise.resolve(data.rows);
    }).catch(function (err) {
      return Promise.reject(err);
    });
  }

  createTable(data) {
    if (data.count === 0) {
      log.info('Running createTable "', this.tableName, '" for', data.dbschema);
      var schema = data.dbschema;
      var sql = this.getCreateTable(data);
      return this.pgModel.promise_query(sql).then(function (data) {
        log.info(`Table ${this.tableName} created at ${schema}`);
        return Promise.resolve(data.rows);
      }.bind(this)).catch(function (err) {
        return Promise.reject(err);
      });
    } else {
      return Promise.resolve([true]);
    }
  }

  createCartoTable(data, idScope) {
    log.info('Running createCartoTable for', data.dbschema);
    if (data.count == 0) {
      var sql = this.getCreateCartoTable(data, idScope);
      // `this.cartoModels[idScope]` don't need to be checked, the function that calls `createCartoTable` checks it
      return this.cartoModels[idScope].promise_query({ query: sql });
    } else {
      return Promise.resolve([true]);
    }
  }

  schedule() {
    if (this.cfg.schedule) {
      this.scopes.forEach(function (scope) {
        log.info('Enqueueing', this.cfg.type, 'for', scope.id_scope);
        // Always use scope local timezone because node-scheduler does not support timezones yet
        var scheduler = translatedToTimezone(this.cfg.schedule, scope.timezone);

        if (this.cfg.carto) {
          schedule.scheduleJob(scheduler, function () {
            let jobData = JSON.parse(JSON.stringify(this.cfg));
            jobData.idScope = scope.id_scope;
            jobData.dbschema = scope.dbschema;
            addJob(jobData.type, jobData);
          }.bind(this));

          schedule.scheduleJob(scheduler, function () {
            let jobData = JSON.parse(JSON.stringify(this.cfg));
            jobData.idScope = scope.id_scope;
            jobData.dbschema = scope.dbschema;
            jobData.carto = false;
            addJob(jobData.type, jobData);
          }.bind(this));
        } else {
          schedule.scheduleJob(scheduler, function () {
            let jobData = JSON.parse(JSON.stringify(this.cfg));
            jobData.idScope = scope.id_scope;
            jobData.dbschema = scope.dbschema;
            jobData.carto = false;
            addJob(jobData.type, jobData);
          }.bind(this));
        }
      }.bind(this));
    } else {
      log.info('Adding not scheduled job', this.cfg.type);
      addJob(this.cfg.type, this.cfg);
    }
  }

  // Mandatory overriden methods
  getCreateTable(data) {
    throw new Error('NotImplementedError: getCreateTable method MUST be overriden.');
  }

  getCreateCartoTable(data, idScope) {
    throw new Error('NotImplementedError: getCreateCartoTable method MUST be overriden.');
  }

  aggregate(job, done) {
    if (job.data.carto && !this.cartoModels[job.data.idScope]) {
      var jobInfo = `job ${job.id}: type '${job.type}' - title '${job.data.title}'`;
      var err = new Error(`${jobInfo} FAILED: idScope is missing (${job.data.idScope}) and the Carto model couldn't be found`);
      log.error(err);
      return done(err);
    }

    process.send(cluster.worker.id);
    return this._aggregate(job, done);
  }

  _aggregate(job, done) {
    throw new Error('NotImplementedError: aggregate method MUST be overriden.');
  }

}

module.exports = BaseJob;